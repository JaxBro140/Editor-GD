<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Geometry Dash Style Editor ‚Äì Mobile, Scaling, Spikes, Triggers</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #111;
      color: #eee;
      display: flex;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }
    #sidebar {
      width: 280px;
      background: #181818;
      border-right: 2px solid #333;
      padding: 10px;
      box-sizing: border-box;
    }
    #sidebar h2 {
      margin-top: 0;
      font-size: 18px;
    }
    #sidebar button {
      margin: 4px 0;
      width: 100%;
      padding: 6px;
      border: none;
      cursor: pointer;
      background: #333;
      color: #eee;
      font-size: 14px;
    }
    #sidebar button.active {
      background: #0a84ff;
    }
    #sidebar .palette {
      margin-top: 10px;
    }
    #sidebar .palette button {
      width: 48%;
      margin-right: 2%;
    }
    #sidebar .palette button:nth-child(2n) {
      margin-right: 0;
    }
    #sidebar small {
      display: block;
      margin-top: 10px;
      color: #aaa;
      font-size: 11px;
      line-height: 1.4;
    }
    #game-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #05070a;
      position: relative;
    }
    canvas {
      background: #000;
      border: 2px solid #333;
      image-rendering: pixelated;
      touch-action: none;
    }
    #mode-indicator {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 10px;
      background: rgba(0,0,0,0.7);
      border-radius: 4px;
      font-size: 13px;
    }

    /* Mobile controls */
    .mobile-controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      display: none;
      gap: 6px;
      z-index: 10;
      font-size: 0;
    }
    .mobile-controls button {
      min-width: 40px;
      min-height: 40px;
      margin: 2px;
      border-radius: 6px;
      border: none;
      background: rgba(40,40,40,0.9);
      color: #fff;
      font-size: 16px;
      font-weight: bold;
    }
    #editor-mobile-controls {
      display: none;
      flex-direction: column;
    }
    #editor-mobile-move {
      display: grid;
      grid-template-columns: repeat(3, 40px);
      grid-template-rows: repeat(2, 40px);
      justify-content: start;
      align-items: center;
    }
    #editor-mobile-move button {
      margin: 2px;
    }
    #editor-mobile-scale {
      margin-top: 4px;
      display: flex;
      flex-wrap: wrap;
    }
    #play-mobile-controls {
      display: none;
      width: 100%;
      justify-content: space-between;
      padding: 0 10px;
      box-sizing: border-box;
    }
    #play-mobile-left {
      display: flex;
      gap: 6px;
    }
    #play-mobile-right {
      display: flex;
      gap: 6px;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>GD Style Editor</h2>
    <button id="modeEditorBtn" class="active">Editor Mode</button>
    <button id="modePlayBtn">Play Mode</button>

    <div class="palette">
      <h3>Palette</h3>
      <button data-type="block" class="palette-btn active">Block</button>
      <button data-type="jumpPad" class="palette-btn">Jump Pad</button>
      <button data-type="spike" class="palette-btn">Spike</button>
      <button data-type="start" class="palette-btn">Start Pos</button>
      <button data-type="goal" class="palette-btn">Goal</button>
      <button data-type="moveTrigger" class="palette-btn">Move Trigger</button>
      <button data-type="spawnTrigger" class="palette-btn">Spawn Trigger</button>
    </div>

    <button id="clearBtn">Clear Level</button>
    <small>
      Editor (keyboard):<br>
      ‚Ä¢ Click empty grid: place current object.<br>
      ‚Ä¢ Click existing object: select it.<br>
      ‚Ä¢ Selected: W/A/S/D = move by 1 cell.<br>
      ‚Ä¢ Selected: R = rotate (Jump Pad & Start & Spike).<br>
      ‚Ä¢ Selected: Arrow keys = scale (stretch/warp).<br>
      &nbsp;&nbsp;‚Üë/‚Üì = taller/shorter, ‚Üê/‚Üí = wider/narrower.<br><br>
      Triggers:<br>
      ‚Ä¢ Move Trigger: prompts for target ID, moveX, moveY, duration (frames).<br>
      ‚Ä¢ Spawn Trigger: prompts for teleport X/Y (grid coords).<br><br>
      Play:<br>
      ‚Ä¢ A/D or ‚Üê/‚Üí to move, Space/‚Üë/W to jump.<br>
      ‚Ä¢ Jump Pad: launches based on rotation (up/right/down/left).<br>
      ‚Ä¢ Spike: kills on touch (any side).<br>
      ‚Ä¢ Start rotation: affects player facing direction at start.<br><br>
      Mobile:<br>
      ‚Ä¢ Editor: on-screen buttons to move/rotate/scale selected object.<br>
      ‚Ä¢ Play: on-screen buttons to move and jump.
    </small>
  </div>

  <div id="game-container">
    <div id="mode-indicator">Mode: Editor</div>
    <canvas id="game" width="960" height="540"></canvas>

    <!-- Mobile editor controls -->
    <div id="editor-mobile-controls" class="mobile-controls">
      <div id="editor-mobile-move">
        <button id="em-up">‚¨ÜÔ∏è</button>
        <button disabled style="opacity:0;"></button>
        <button id="em-rotate">üîÑ</button>
        <button id="em-left">‚¨ÖÔ∏è</button>
        <button id="em-down">‚¨áÔ∏è</button>
        <button id="em-right">‚û°Ô∏è</button>
      </div>
      <div id="editor-mobile-scale">
        <button id="em-scale-up">T+</button>
        <button id="em-scale-down">T-</button>
        <button id="em-scale-right">W+</button>
        <button id="em-scale-left">W-</button>
      </div>
    </div>

    <!-- Mobile play controls -->
    <div id="play-mobile-controls" class="mobile-controls">
      <div id="play-mobile-left">
        <button id="pm-left">‚óÄÔ∏è</button>
        <button id="pm-right">‚ñ∂Ô∏è</button>
      </div>
      <div id="play-mobile-right">
        <button id="pm-jump">‚¨ÜÔ∏è</button>
      </div>
    </div>
  </div>

  <script>
    const isMobile = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent);

    // --- Basic setup ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const GRID_SIZE = 30;
    const COLS = Math.floor(canvas.width / GRID_SIZE);
    const ROWS = Math.floor(canvas.height / GRID_SIZE);

    // Level data
    const tiles = []; // {id,x,y,type,rotation,scaleX,scaleY,...}
    let nextID = 1;

    let startPos = {
      x: 2 * GRID_SIZE,
      y: (ROWS - 3) * GRID_SIZE,
      rotation: 0
    };
    let goalPos = {
      x: (COLS - 4) * GRID_SIZE,
      y: (ROWS - 3) * GRID_SIZE
    };

    // Modes
    let mode = 'editor';
    let currentType = 'block';

    // Selection
    let selected = null;

    // Player
    const player = {
      x: startPos.x,
      y: startPos.y,
      w: GRID_SIZE * 0.8,
      h: GRID_SIZE * 0.8,
      vx: 0,
      vy: 0,
      onGround: false,
      facing: 1,
      color: '#00e1ff'
    };

    const keys = {};

    // Mobile play flags
    let mobileLeft = false;
    let mobileRight = false;
    let mobileJump = false;

    // Tweens
    const activeTweens = [];

    // --- UI elements ---
    const modeEditorBtn = document.getElementById('modeEditorBtn');
    const modePlayBtn = document.getElementById('modePlayBtn');
    const modeIndicator = document.getElementById('mode-indicator');
    const clearBtn = document.getElementById('clearBtn');
    const paletteButtons = document.querySelectorAll('.palette-btn');

    const editorMobileControls = document.getElementById('editor-mobile-controls');
    const playMobileControls = document.getElementById('play-mobile-controls');

    const emUp = document.getElementById('em-up');
    const emDown = document.getElementById('em-down');
    const emLeft = document.getElementById('em-left');
    const emRight = document.getElementById('em-right');
    const emRotate = document.getElementById('em-rotate');
    const emScaleUp = document.getElementById('em-scale-up');
    const emScaleDown = document.getElementById('em-scale-down');
    const emScaleRight = document.getElementById('em-scale-right');
    const emScaleLeft = document.getElementById('em-scale-left');

    const pmLeft = document.getElementById('pm-left');
    const pmRight = document.getElementById('pm-right');
    const pmJump = document.getElementById('pm-jump');

    modeEditorBtn.onclick = () => setMode('editor');
    modePlayBtn.onclick = () => setMode('play');
    clearBtn.onclick = () => {
      tiles.length = 0;
      nextID = 1;
      startPos = {
        x: 2 * GRID_SIZE,
        y: (ROWS - 3) * GRID_SIZE,
        rotation: 0
      };
      goalPos = {
        x: (COLS - 4) * GRID_SIZE,
        y: (ROWS - 3) * GRID_SIZE
      };
      selected = null;
      resetPlayer();
    };

    paletteButtons.forEach(btn => {
      btn.onclick = () => {
        paletteButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentType = btn.dataset.type;
      };
    });

    function updateMobileUI() {
      if (!isMobile) {
        editorMobileControls.style.display = 'none';
        playMobileControls.style.display = 'none';
        return;
      }
      if (mode === 'editor') {
        editorMobileControls.style.display = 'flex';
        playMobileControls.style.display = 'none';
      } else {
        editorMobileControls.style.display = 'none';
        playMobileControls.style.display = 'flex';
      }
    }

    function setMode(newMode) {
      mode = newMode;
      if (mode === 'editor') {
        modeEditorBtn.classList.add('active');
        modePlayBtn.classList.remove('active');
        modeIndicator.textContent = 'Mode: Editor';
      } else {
        modePlayBtn.classList.add('active');
        modeEditorBtn.classList.remove('active');
        modeIndicator.textContent = 'Mode: Play';
        selected = null;
        resetPlayer();
      }
      updateMobileUI();
    }

    function resetPlayer() {
      player.x = startPos.x;
      player.y = startPos.y;
      player.vx = 0;
      player.vy = 0;
      player.onGround = false;

      const r = ((startPos.rotation % 360) + 360) % 360;
      if (r === 0 || r === 90) player.facing = 1;
      else player.facing = -1;
    }

    // --- Input handling ---
    window.addEventListener('keydown', e => {
      const key = e.key.toLowerCase();
      keys[key] = true;

      if (mode === 'editor' && selected) {
        if (['w','a','s','d','r','arrowup','arrowdown','arrowleft','arrowright'].includes(key)) {
          e.preventDefault();
          handleEditorSelectionKey(key);
        }
      }
    });

    window.addEventListener('keyup', e => {
      keys[e.key.toLowerCase()] = false;
    });

    function handleEditorSelectionKey(key) {
      if (!selected) return;

      if (selected.kind === 'tile') {
        const t = selected.ref;
        t.scaleX = t.scaleX || 1;
        t.scaleY = t.scaleY || 1;

        if (key === 'w') t.y -= 1;
        if (key === 's') t.y += 1;
        if (key === 'a') t.x -= 1;
        if (key === 'd') t.x += 1;

        if (key === 'r' && (t.type === 'jumpPad' || t.type === 'spike')) {
          t.rotation = ((t.rotation || 0) + 90) % 360;
        }

        if (key === 'arrowright') t.scaleX += 1;
        if (key === 'arrowleft') t.scaleX = Math.max(1, t.scaleX - 1);
        if (key === 'arrowup') t.scaleY += 1;
        if (key === 'arrowdown') t.scaleY = Math.max(1, t.scaleY - 1);
      } else if (selected.kind === 'start') {
        if (key === 'w') startPos.y -= GRID_SIZE;
        if (key === 's') startPos.y += GRID_SIZE;
        if (key === 'a') startPos.x -= GRID_SIZE;
        if (key === 'd') startPos.x += GRID_SIZE;
        if (key === 'r') {
          startPos.rotation = ((startPos.rotation || 0) + 90) % 360;
        }
      } else if (selected.kind === 'goal') {
        if (key === 'w') goalPos.y -= GRID_SIZE;
        if (key === 's') goalPos.y += GRID_SIZE;
        if (key === 'a') goalPos.x -= GRID_SIZE;
        if (key === 'd') goalPos.x += GRID_SIZE;
      }
    }

    canvas.addEventListener('mousedown', e => {
      if (mode !== 'editor') return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const gx = Math.floor(mx / GRID_SIZE);
      const gy = Math.floor(my / GRID_SIZE);

      const startGX = Math.floor(startPos.x / GRID_SIZE);
      const startGY = Math.floor(startPos.y / GRID_SIZE);
      const goalGX = Math.floor(goalPos.x / GRID_SIZE);
      const goalGY = Math.floor(goalPos.y / GRID_SIZE);

      if (gx === startGX && gy === startGY) {
        selected = { kind: 'start' };
        return;
      }
      if (gx === goalGX && gy === goalGY) {
        selected = { kind: 'goal' };
        return;
      }

      const existing = tiles.find(t =>
        gx >= Math.round(t.x) &&
        gx < Math.round(t.x) + (t.scaleX || 1) &&
        gy >= Math.round(t.y) &&
        gy < Math.round(t.y) + (t.scaleY || 1)
      );
      if (existing) {
        selected = { kind: 'tile', ref: existing };
        return;
      }

      selected = null;

      if (currentType === 'start') {
        startPos.x = gx * GRID_SIZE;
        startPos.y = gy * GRID_SIZE;
        selected = { kind: 'start' };
        return;
      }
      if (currentType === 'goal') {
        goalPos.x = gx * GRID_SIZE;
        goalPos.y = gy * GRID_SIZE;
        selected = { kind: 'goal' };
        return;
      }

      const tile = {
        id: nextID++,
        x: gx,
        y: gy,
        type: currentType,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        targetID: null,
        moveX: 0,
        moveY: 0,
        duration: 60,
        targetX: null,
        targetY: null
      };

      if (currentType === 'moveTrigger') {
        const targetIDStr = prompt('Move Trigger: target object ID (number). You can see IDs in editor rendering.', '1');
        const moveXStr = prompt('Move Trigger: moveX in grid cells (positive = right, negative = left).', '3');
        const moveYStr = prompt('Move Trigger: moveY in grid cells (positive = down, negative = up).', '0');
        const durationStr = prompt('Move Trigger: duration in frames (60 ‚âà 1 second).', '60');

        tile.targetID = parseInt(targetIDStr || '1', 10);
        tile.moveX = parseInt(moveXStr || '0', 10);
        tile.moveY = parseInt(moveYStr || '0', 10);
        tile.duration = Math.max(1, parseInt(durationStr || '60', 10));
      }

      if (currentType === 'spawnTrigger') {
        const txStr = prompt('Spawn Trigger: teleport X grid coordinate.', String(gx));
        const tyStr = prompt('Spawn Trigger: teleport Y grid coordinate.', String(gy));
        tile.targetX = parseInt(txStr || String(gx), 10) * GRID_SIZE;
        tile.targetY = parseInt(tyStr || String(gy), 10) * GRID_SIZE;
      }

      tiles.push(tile);
      selected = { kind: 'tile', ref: tile };
    });

    // --- Physics and collision ---
    const GRAVITY = 0.6;
    const MOVE_SPEED = 4;
    const JUMP_FORCE = -11;
    const JUMP_PAD_FORCE = 16;

    function updatePlayer() {
      let left = keys['a'] || keys['arrowleft'] || mobileLeft;
      let right = keys['d'] || keys['arrowright'] || mobileRight;
      let jump = keys[' '] || keys['arrowup'] || keys['w'] || mobileJump;

      player.vx = 0;
      if (left) player.vx -= MOVE_SPEED;
      if (right) player.vx += MOVE_SPEED;

      player.vy += GRAVITY;

      if (jump && player.onGround) {
        player.vy = JUMP_FORCE;
        player.onGround = false;
      }

      moveAndCollide(player, player.vx, 0);
      moveAndCollide(player, 0, player.vy);

      if (aabbOverlap(
        player.x, player.y, player.w, player.h,
        goalPos.x, goalPos.y, GRID_SIZE, GRID_SIZE
      )) {
        resetPlayer();
      }

      checkHazards();
      checkTriggers();

      mobileJump = false;
    }

    function moveAndCollide(obj, dx, dy) {
      obj.x += dx;
      obj.y += dy;

      obj.onGround = false;

      for (const t of tiles) {
        if (t.type === 'block' || t.type === 'jumpPad') {
          const sx = t.scaleX || 1;
          const sy = t.scaleY || 1;
          const tx = t.x * GRID_SIZE;
          const ty = t.y * GRID_SIZE;
          const tw = GRID_SIZE * sx;
          const th = GRID_SIZE * sy;

          if (aabbOverlap(obj.x, obj.y, obj.w, obj.h, tx, ty, tw, th)) {
            if (dx > 0) obj.x = tx - obj.w;
            if (dx < 0) obj.x = tx + tw;
            if (dy > 0) {
              obj.y = ty - obj.h;
              obj.vy = 0;
              obj.onGround = true;

              if (t.type === 'jumpPad') {
                const r = ((t.rotation || 0) % 360 + 360) % 360;
                if (r === 0) {
                  obj.vy = -JUMP_PAD_FORCE;
                } else if (r === 90) {
                  obj.vx = JUMP_PAD_FORCE;
                } else if (r === 180) {
                  obj.vy = JUMP_PAD_FORCE;
                } else if (r === 270) {
                  obj.vx = -JUMP_PAD_FORCE;
                }
                obj.onGround = false;
              }
            }
            if (dy < 0) {
              obj.y = ty + th;
              obj.vy = 0;
            }
          }
        }
      }
    }

    function aabbOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
      return (
        x1 < x2 + w2 &&
        x1 + w1 > x2 &&
        y1 < y2 + h2 &&
        y1 + h1 > y2
      );
    }

    // --- Hazards (spikes) ---
    function checkHazards() {
      for (const t of tiles) {
        if (t.type !== 'spike') continue;
        const sx = t.scaleX || 1;
        const sy = t.scaleY || 1;
        const tx = t.x * GRID_SIZE;
        const ty = t.y * GRID_SIZE;
        const tw = GRID_SIZE * sx;
        const th = GRID_SIZE * sy;

        if (aabbOverlap(player.x, player.y, player.w, player.h, tx, ty, tw, th)) {
          resetPlayer();
          return;
        }
      }
    }

    // --- Trigger logic ---
    function checkTriggers() {
      for (const t of tiles) {
        if (t.type !== 'moveTrigger' && t.type !== 'spawnTrigger') continue;

        const sx = t.scaleX || 1;
        const sy = t.scaleY || 1;
        const tx = t.x * GRID_SIZE;
        const ty = t.y * GRID_SIZE;
        const tw = GRID_SIZE * sx;
        const th = GRID_SIZE * sy;

        if (!aabbOverlap(player.x, player.y, player.w, player.h, tx, ty, tw, th)) {
          continue;
        }

        if (t.type === 'spawnTrigger') {
          if (t.targetX != null && t.targetY != null) {
            player.x = t.targetX;
            player.y = t.targetY;
            player.vx = 0;
            player.vy = 0;
            player.onGround = false;
          }
        }

        if (t.type === 'moveTrigger') {
          const target = tiles.find(o => o.id === t.targetID);
          if (target) {
            startMoveTween(
              target,
              t.moveX * GRID_SIZE,
              t.moveY * GRID_SIZE,
              t.duration
            );
          }
        }
      }
    }

    function startMoveTween(obj, dx, dy, duration) {
      activeTweens.push({
        obj,
        startX: obj.x * GRID_SIZE,
        startY: obj.y * GRID_SIZE,
        dx,
        dy,
        duration,
        time: 0
      });
    }

    function updateTweens() {
      for (let i = activeTweens.length - 1; i >= 0; i--) {
        const t = activeTweens[i];
        t.time++;

        const p = t.time / t.duration;
        if (p >= 1) {
          const finalX = t.startX + t.dx;
          const finalY = t.startY + t.dy;
          t.obj.x = Math.round(finalX / GRID_SIZE);
          t.obj.y = Math.round(finalY / GRID_SIZE);
          activeTweens.splice(i, 1);
          continue;
        }

        const curX = t.startX + t.dx * p;
        const curY = t.startY + t.dy * p;
        t.obj.x = curX / GRID_SIZE;
        t.obj.y = curY / GRID_SIZE;
      }
    }

    // --- Rendering ---
    function drawGrid() {
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1;
      for (let x = 0; x <= COLS; x++) {
        ctx.beginPath();
        ctx.moveTo(x * GRID_SIZE, 0);
        ctx.lineTo(x * GRID_SIZE, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * GRID_SIZE);
        ctx.lineTo(canvas.width, y * GRID_SIZE);
        ctx.stroke();
      }
    }

    function drawTiles() {
      for (const t of tiles) {
        const sx = t.scaleX || 1;
        const sy = t.scaleY || 1;
        const baseX = t.x * GRID_SIZE;
        const baseY = t.y * GRID_SIZE;

        if (t.type === 'block') {
          ctx.fillStyle = '#444';
          ctx.fillRect(baseX, baseY, GRID_SIZE * sx, GRID_SIZE * sy);
          ctx.strokeStyle = '#777';
          ctx.strokeRect(baseX, baseY, GRID_SIZE * sx, GRID_SIZE * sy);
        } else if (t.type === 'jumpPad') {
          ctx.save();
          ctx.translate(baseX + (GRID_SIZE * sx) / 2, baseY + (GRID_SIZE * sy) / 2);
          const r = ((t.rotation || 0) * Math.PI) / 180;
          ctx.rotate(r);
          ctx.scale(sx, sy);
          ctx.translate(-GRID_SIZE / 2, -GRID_SIZE / 2);

          ctx.fillStyle = '#00ff7f';
          ctx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
          ctx.strokeStyle = '#aaffcc';
          ctx.strokeRect(0, 0, GRID_SIZE, GRID_SIZE);
          ctx.strokeStyle = '#003322';
          ctx.beginPath();
          ctx.moveTo(4, GRID_SIZE - 4);
          ctx.lineTo(GRID_SIZE / 2, 4);
          ctx.lineTo(GRID_SIZE - 4, GRID_SIZE - 4);
          ctx.stroke();

          ctx.restore();
        } else if (t.type === 'spike') {
          ctx.save();
          ctx.translate(baseX + (GRID_SIZE * sx) / 2, baseY + (GRID_SIZE * sy) / 2);
          const r = ((t.rotation || 0) * Math.PI) / 180;
          ctx.rotate(r);
          ctx.scale(sx, sy);
          ctx.translate(-GRID_SIZE / 2, -GRID_SIZE / 2);

          ctx.fillStyle = '#ff4444';
          ctx.beginPath();
          ctx.moveTo(0, GRID_SIZE);
          ctx.lineTo(GRID_SIZE / 2, 0);
          ctx.lineTo(GRID_SIZE, GRID_SIZE);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = '#ffaaaa';
          ctx.stroke();

          ctx.restore();
        } else if (t.type === 'moveTrigger') {
          ctx.fillStyle = '#ff66ff';
          ctx.fillRect(baseX, baseY, GRID_SIZE * sx, GRID_SIZE * sy);
          ctx.strokeStyle = '#ffffff';
          ctx.strokeRect(baseX, baseY, GRID_SIZE * sx, GRID_SIZE * sy);
          ctx.fillStyle = '#000';
          ctx.font = '10px sans-serif';
          ctx.fillText('M', baseX + 10, baseY + 18);
        } else if (t.type === 'spawnTrigger') {
          ctx.fillStyle = '#66ccff';
          ctx.fillRect(baseX, baseY, GRID_SIZE * sx, GRID_SIZE * sy);
          ctx.strokeStyle = '#ffffff';
          ctx.strokeRect(baseX, baseY, GRID_SIZE * sx, GRID_SIZE * sy);
          ctx.fillStyle = '#000';
          ctx.font = '10px sans-serif';
          ctx.fillText('S', baseX + 10, baseY + 18);
        }

        if (mode === 'editor') {
          ctx.fillStyle = '#fff';
          ctx.font = '9px monospace';
          ctx.fillText(String(t.id), baseX + 2, baseY + 10);
        }

        if (selected && selected.kind === 'tile' && selected.ref === t) {
          ctx.strokeStyle = '#0af';
          ctx.lineWidth = 2;
          ctx.strokeRect(baseX + 1, baseY + 1, GRID_SIZE * sx - 2, GRID_SIZE * sy - 2);
        }
      }
    }

    function drawStartAndGoal() {
      ctx.save();
      ctx.translate(startPos.x + GRID_SIZE / 2, startPos.y + GRID_SIZE / 2);
      const r = ((startPos.rotation || 0) * Math.PI) / 180;
      ctx.rotate(r);
      ctx.translate(-GRID_SIZE / 2, -GRID_SIZE / 2);

      ctx.fillStyle = '#0a84ff';
      ctx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
      ctx.fillStyle = '#fff';
      ctx.font = '12px sans-serif';
      ctx.fillText('S', 10, 20);

      ctx.restore();

      if (selected && selected.kind === 'start') {
        ctx.strokeStyle = '#0af';
        ctx.lineWidth = 2;
        ctx.strokeRect(startPos.x + 1, startPos.y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
      }

      ctx.fillStyle = '#ffcc00';
      ctx.fillRect(goalPos.x, goalPos.y, GRID_SIZE, GRID_SIZE);
      ctx.fillStyle = '#000';
      ctx.font = '12px sans-serif';
      ctx.fillText('G', goalPos.x + 10, goalPos.y + 20);

      if (selected && selected.kind === 'goal') {
        ctx.strokeStyle = '#0af';
        ctx.lineWidth = 2;
        ctx.strokeRect(goalPos.x + 1, goalPos.y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
      }
    }

    function drawPlayer() {
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.w, player.h);
    }

    // --- Main loop ---
    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawGrid();
      updateTweens();
      drawTiles();
      drawStartAndGoal();

      if (mode === 'play') {
        updatePlayer();
        drawPlayer();
      }

      requestAnimationFrame(loop);
    }

    // --- Mobile controls wiring ---
    function bindButtonHold(btn, onDown, onUp) {
      const start = e => {
        e.preventDefault();
        onDown();
      };
      const end = e => {
        e.preventDefault();
        onUp();
      };
      btn.addEventListener('mousedown', start);
      btn.addEventListener('touchstart', start, { passive: false });
      window.addEventListener('mouseup', end);
      window.addEventListener('touchend', end, { passive: false });
    }

    if (isMobile) {
      // Editor move
      emUp.addEventListener('click', e => { e.preventDefault(); handleEditorSelectionKey('w'); });
      emDown.addEventListener('click', e => { e.preventDefault(); handleEditorSelectionKey('s'); });
      emLeft.addEventListener('click', e => { e.preventDefault(); handleEditorSelectionKey('a'); });
      emRight.addEventListener('click', e => { e.preventDefault(); handleEditorSelectionKey('d'); });
      emRotate.addEventListener('click', e => { e.preventDefault(); handleEditorSelectionKey('r'); });

      emScaleUp.addEventListener('click', e => { e.preventDefault(); handleEditorSelectionKey('arrowup'); });
      emScaleDown.addEventListener('click', e => { e.preventDefault(); handleEditorSelectionKey('arrowdown'); });
      emScaleRight.addEventListener('click', e => { e.preventDefault(); handleEditorSelectionKey('arrowright'); });
      emScaleLeft.addEventListener('click', e => { e.preventDefault(); handleEditorSelectionKey('arrowleft'); });

      // Play movement
      bindButtonHold(pmLeft,
        () => { mobileLeft = true; },
        () => { mobileLeft = false; }
      );
      bindButtonHold(pmRight,
        () => { mobileRight = true; },
        () => { mobileRight = false; }
      );
      pmJump.addEventListener('mousedown', e => { e.preventDefault(); mobileJump = true; });
      pmJump.addEventListener('touchstart', e => { e.preventDefault(); mobileJump = true; }, { passive: false });
    }

    updateMobileUI();
    loop();
  </script>
</body>
</html>
